# detect fingerprinting
detectfp.js application/javascript
(function() {
	// helpers
	const itemInList = (list, item) => list.indexOf(item) > -1
	const listRand = (list) => list[Math.floor(Math.random() * list.length)]
	const evenRand = (min, max) =>
		(Math.floor(Math.random() * ((max/2) - min + 1)) + min)*2
	const rand = (min, max) =>
		(Math.floor(Math.random() * (max - min + 1)) + min)
	const randomRGBA = () => {
	    const clr = () => Math.round(Math.random()*255)
	    return `rgba(${clr()},${clr()},${clr()},${Math.random().toFixed(1)})`
	}
	const randomFont = () => {
		const fontFamily = [
			'Arial','Arial Black','Arial Narrow','Courier','Courier New','Georgia','Helvetica',
			'Impact','Lucida Console','monospace','Tahoma','Times','Times New Roman','Verdana'
		]
		const fontSize = Math.floor((Math.random() * 100) + 12)
		const rand = Math.floor(Math.random()*fontFamily.length)
		return `${fontSize}px '${fontFamily[rand]}'`
	}
	const hashify = str => {
		let i, len, hash = 0x811c9dc5
		for(i = 0, len = str.length; i < len; i++) {
			hash = Math.imul(31, hash) + str.charCodeAt(i)|0
	    	}
		return ("0000000" + (hash >>> 0).toString(16)).substr(-8)
	}
	// randomize
	const randomized = {}
	const doNotTrack = () => {
		const val = listRand(['0','1', 'unspecified'])
		randomized.doNotTrack = ['doNotTrack', val]
		return () => val
	}
	function canLieTouch() {
	  const userAgent = navigator.userAgent
	  const os = (
	    /windows phone/ig.test(userAgent)? 'Windows Phone':
	    /win(dows|16|32|64|95|98|nt)|wow64/ig.test(userAgent)? 'Windows':
	    /android/ig.test(userAgent)? 'Android': 
	    /linux/ig.test(userAgent)? 'Linux': 
	    /ios/ig.test(userAgent)? 'iOS': 
	    /mac/ig.test(userAgent)? 'Mac':
	    /cros/ig.test(userAgent)? 'CrOS':
	    'Other' 
	  )
	  const touchOS = (/^(Windows(| Phone)|CrOS|Android|iOS)$/ig.test(os))
	  let touchAPI = ('ontouchstart' in window)
	  try { document.createEvent('TouchEvent') }
	  catch (err) { touchAPI = false }
	  return () => touchOS && touchAPI
	}
	const maxTouchPoints = () => {
		const val = rand(1, 10)
		randomized.maxTouchPoints = ['maxTouchPoints', val]
		return () => val
	}
	const hardwareConcurrency = () => {
		const val = rand(1, 16)
		randomized.hardwareConcurrency = ['hardwareConcurrency', val]
		return () => val
	}
	const deviceMemory = () => {
		const val = evenRand(2, 32)
		randomized.deviceMemory = ['deviceMemory', val]
		return () => val
	}
	const screenRatio = () => {
		const val = listRand([{w:1920,h:1080},{w:1440,h:900},{w:1280,h:800},{w:1600,h:900}])
		return () => val
	}
	const availScreenRatio = () => {
		const val = listRand([{w:1920,h:1080},{w:1440,h:900},{w:1280,h:800},{w:1600,h:900}])
		val.w = val.w-rand(1, 20)
		val.h = val.h-rand(1, 20)
		return () => val
	}
	const screenRandomized = (prop, val) => {
		randomized[prop] = [prop, val]
		return val
	}
	const canvasRandomized = () => {
		const canvas = window.document.createElement('canvas')
		const txt = 'ðŸš€ Private'
		const context = canvas.getContext('2d')
		context.textBaseline = 'top'
		context.textBaseline = 'alphabetic'
		context.font = randomFont()
		context.fillStyle = randomRGBA()
		context.fillRect(125, 1, 62, 20)
		context.fillText(txt, 2, 15)
		const dataURL = canvas.toDataURL()
		randomized.toDataURL = ['HTMLCanvasElement.toDataURL', hashif(dataURL)]
		return () => dataURL
	}
	// cached
	const cachedRandomized = {
		doNotTrack: doNotTrack(),
		canLieTouch: canLieTouch(),
		maxTouchPoints: maxTouchPoints(),
		hardwareConcurrency: hardwareConcurrency(),
		deviceMemory: deviceMemory(),
		screenRatio: screenRatio(),
		availScreenRatio: availScreenRatio(),
		cachedRandomCanvas: cachedRandomCanvas()
	}
	// structs
	const navigatorProps = {
		appVersion: navigator.appVersion,
		appCodeName: navigator.appCodeName,
		deviceMemory: cachedRandomized.deviceMemory(),
		doNotTrack: cachedRandomized.doNotTrack(),
		hardwareConcurrency: cachedRandomized.hardwareConcurrency(),
		languages: navigator.languages,
		maxTouchPoints: cachedRandomized.canLieTouch()? cachedRandomized.maxTouchPoints(): navigator.maxTouchPoints,
		mimeTypes: [], // Block
		platform: navigator.platform,
		plugins: [], // Block
		userAgent: navigator.userAgent,
		vendor: '' // Block
	}
	const screenProps = {
		width: screenRandomized('screen.width', cachedRandomized.screenRatio.w),
		height: screenRandomized('screen.height', cachedRandomized.screenRatio.h),
		availWidth: screenRandomized('screen.availWidth', cachedRandomized.availScreenRatio),
		availHeight: screenRandomized('screen.availHeight', cachedRandomized.availScreenRatio),
		availTop: screen.availTop,
		availLeft: screen.availLeft,
		colorDepth: screen.colorDepth,
		pixelDepth: screen.pixelDepth
	}
	const dateProps = {
		getTimezoneOffset: Date.prototype.getTimezoneOffset
	}
	const intlProps = {
		resolvedOptions: Intl.DateTimeFormat.prototype.resolvedOptions
	}
	const mathProps = {
		acos: Math.acos,
		acosh: Math.acosh,
		asin: Math.asin,
		asinh: Math.asinh,
		cosh: Math.cosh,
		expm1: Math.expm1,
		sinh: Math.sinh
	}
	const mediaDeviceProps = {
		enumerateDevices: navigator.mediaDevices.enumerateDevices
	}
	const videoElementProps = {
		canPlayType: HTMLVideoElement.prototype.canPlayType
	}
	const mediaElementProps = {
		canPlayType: HTMLMediaElement.prototype.canPlayType
	}
	const mediaSourceProps = {
		isTypeSupported: MediaSource.isTypeSupported
	}
	const mediaRecorderProps = {
		isTypeSupported: MediaRecorder.isTypeSupported
	}
	const speechProps = {
		getVoices: () => [] // Block speechSynthesis.getVoices
	}
	const performanceProps = {
		now: performance.now
	}
	const elemRectProps = {
		getBoundingClientRect: Element.prototype.getBoundingClientRect,
		getClientRects: Element.prototype.getClientRects
	}
	const rangeRectProps = {
		getBoundingClientRect: Range.prototype.getBoundingClientRect,
		getClientRects: Range.prototype.getClientRects
	}
	const webglProps = {
		shaderSource: WebGLRenderingContext.prototype.shaderSource,
		getExtension: WebGLRenderingContext.prototype.getExtension,
		getParameter: WebGLRenderingContext.prototype.getParameter,
		getSupportedExtensions: WebGLRenderingContext.prototype.getSupportedExtensions
	}
	const canvasProps = {
		toDataURL: cachedRandomized.cachedRandomCanvas(),
		toBlob: HTMLCanvasElement.prototype.toBlob
	}
	const canvasContextProps = {
		getImageData: CanvasRenderingContext2D.prototype.getImageData,
		isPointInPath: CanvasRenderingContext2D.prototype.isPointInPath,
		isPointInStroke: CanvasRenderingContext2D.prototype.isPointInStroke,
		measureText: CanvasRenderingContext2D.prototype.measureText,
	}
	const audioProps = {
		createAnalyser: AudioContext.prototype.createAnalyser,
		createOscillator: AudioContext.prototype.createOscillator,
	}
	// Log Randomized
	const style = () => {
		const colors = [
			`rgba(54,59,116,.${rand(1,6)})`,
			`rgba(103,56,136,.${rand(1,6)})`,
			`rgba(239,79,145,.${rand(1,9)})`,
			`rgba(199,157,215,.${rand(1,9)})`,
			`rgba(77,27,123,.${rand(1,6)})`
		]
		return `padding:4px 0px;background:${listRand(colors)};`
	}
	const randomizedKeys = Object.keys(randomized)
	const hash = hashify(JSON.stringify(randomized))
	console.groupCollapsed(
		`ðŸ§ª Randomized ${randomizedKeys.length} properties (id: ${hash})`
	)
	randomizedKeys.forEach(key => {
		const prop = randomized[key][0]
		const val = randomized[key][1]
		console.log(`%c${prop}: ${val}`, style())
	})
	console.groupEnd()
	// API with Ranking per Unique Impact and Longterm State
	const queryAPI = 'https://developer.mozilla.org/en-US/search?q='
	const propAPI = {
		appVersion: ['navigator.appVersion', 2],
		appCodeName: ['navigator.appCodeName', 1],
		deviceMemory: ['navigator.deviceMemory', 1],
		doNotTrack: ['navigator.doNotTrack', 1],
		hardwareConcurrency: ['navigator.hardwareConcurrency', 1],
		languages: ['navigator.languages', 1],
		maxTouchPoints: ['navigator.maxTouchPoints', 1],
		mimeTypes: ['navigator.mimeTypes', 1],
		platform: ['navigator.platform', 1],
		plugins: ['navigator.plugins', 1],
		userAgent: ['navigator.userAgent', 2],
		vendor: ['navigator.vendor', 1],
		width: ['screen.width', 1],
		height: ['screen.height', 1],
		availWidth: ['screen.availWidth', 1],
		availHeight: ['screen.availHeight', 1],
		availTop: ['screen.availTop', 1],
		availLeft: ['screen.availLeft', 1],
		colorDepth: ['screen.colorDepth', 1],
		pixelDepth: ['screen.pixelDepth', 1],
		getTimezoneOffset: ['Date.prototype.getTimezoneOffset', 1],
		resolvedOptions: ['Intl.DateTimeFormat.prototype.resolvedOptions', 2],
		acos: ['acos: Math.acos', 1],
		acosh: ['Math.acosh', 1],
		asin: ['Math.asin', 1],
		asinh: ['Math.asinh', 1],
		cosh: ['Math.cosh', 1],
		expm1: ['Math.expm1', 1],
		sinh: ['Math.sinh', 1],
		enumerateDevices: ['navigator.mediaDevices.enumerateDevices', 1],
		canPlayType: ['prototype.canPlayType', 1],
		isTypeSupported: ['isTypeSupported', 1],
		getVoices: ['speechSynthesis.getVoices', 1],
		now: ['performance.now', 1],
		getBoundingClientRect: ['prototype.getBoundingClientRect', 2],
		getClientRects: ['prototype.getClientRects', 2],
		offsetWidth: ['HTMLElement.prototype.offsetWidth', 1],
		offsetHeight: ['HTMLElement.prototype.offsetHeight', 1],
		shaderSource: ['WebGLRenderingContext.prototype.shaderSource', 6],
		getExtension: ['WebGLRenderingContext.prototype.getExtension', 2],
		getParameter: ['WebGLRenderingContext.prototype.getParameter', 2],
		getSupportedExtensions: ['WebGLRenderingContext.prototype.getSupportedExtensions', 4],
		toDataURL: ['HTMLCanvasElement.prototype.toDataURL', 6],
		toBlob: ['HTMLCanvasElement.prototype.toBlob', 6],
		getImageData: ['CanvasRenderingContext2D.prototype.getImageData', 6],
		isPointInPath: ['CanvasRenderingContext2D.prototype.isPointInPath', 1],
		isPointInStroke: ['CanvasRenderingContext2D.prototype.isPointInStroke', 1],
		measureText: ['CanvasRenderingContext2D.prototype.measureText', 1],
		font: ['CanvasRenderingContext2D.prototype.font', 1],
		createAnalyser: ['AudioContext.prototype.createAnalyser', 6],
		createOscillator: ['AudioContext.prototype.createOscillator', 6]
	}
	// watcher
	let rankCounter = 0
	let watching = true
	const domain = window.location.hostname
	const fingerprintingRank = 12
	const propsRead = []
	const propsReadAll = {}
	const watch = (prop) => {
		const propDescription = propAPI[prop][0]
		const propRank = propAPI[prop][1]
		const headingStyle = `background:#bcf4de`
		const trace = () => {
			const emojis = propRank >= 6? 'ðŸ¥µ': propRank >= 4? 'ðŸ¥¶': propRank >= 3? 'ðŸ˜±': propRank >=2 ? 'ðŸ˜¨': ''
			console.groupCollapsed(`${emojis} Script read ${propDescription}`)
			console.log(`%cAPI Reference:`, headingStyle)
			console.log(queryAPI+propDescription)
			console.log(`%cAttempting to trace the source (refresh to retry)...`, headingStyle)
			console.trace(document.currentScript?document.currentScript.src:'')
			console.groupEnd()
		}
		const newPropRead = !itemInList(propsRead, propDescription)
		propsReadAll[propDescription]? propsReadAll[propDescription]++: propsReadAll[propDescription]=1
		if (newPropRead) {
			rankCounter += propRank
			propsRead.push(propDescription)
		}
		// counter types
		if (watching && rankCounter >= fingerprintingRank) {
			const warnStyle = `color:green;border:2px solid green;font-weight:bold;padding:5px;`
			console.warn(`%câš”ï¸ Detected excessive data collection (fingerprinting tactics)!`, warnStyle)
			console.groupCollapsed(`ðŸ“” Data Collection Stats`)
			console.log(`%cHow many data points were read?`, headingStyle)
			console.log(propsRead)
			console.log(`%cHow many times was your data read?`, headingStyle)
			console.log(propsReadAll)
			console.log(`%cSearch this host's Privacy Policy:`, headingStyle)
			console.log(`https://duckduckgo.com/?q=%22${domain}%22+%22privacy%22+%22policy%22`)
			console.groupEnd()
			watching = false
		}
		return newPropRead? trace: ()=>{}
	}
	// difinify
	function definify(struct) {
		const redefinedProps = {}
		Object.keys(struct).forEach(prop => {
			redefinedProps[prop] = { get: () => { watch(prop)(); return struct[prop] } }
		})
		return redefinedProps
	}
	function redefine(root, typeOfAttempt = '') {
		Object.defineProperties(root.navigator, definify(navigatorProps))
		Object.defineProperties(root.screen, definify(screenProps))
		Object.defineProperties(root.Date.prototype, definify(dateProps))
		Object.defineProperties(root.Intl.DateTimeFormat.prototype, definify(intlProps))
		Object.defineProperties(root.Math, definify(mathProps))
		Object.defineProperties(root.navigator.mediaDevices, definify(mediaDeviceProps))
		Object.defineProperties(root.HTMLVideoElement.prototype, definify(videoElementProps))
		Object.defineProperties(root.HTMLMediaElement.prototype, definify(mediaElementProps))
		Object.defineProperties(root.MediaSource, definify(mediaSourceProps))
		Object.defineProperties(root.MediaRecorder, definify(mediaRecorderProps))
		Object.defineProperties(root.speechSynthesis, definify(speechProps))
		Object.defineProperties(root.performance, definify(performanceProps))
		Object.defineProperties(root.Element.prototype, definify(elemRectProps))
		Object.defineProperties(root.Range.prototype, definify(rangeRectProps))
		Object.defineProperties(root.WebGLRenderingContext.prototype, definify(webglProps))
		Object.defineProperties(root.HTMLCanvasElement.prototype, definify(canvasProps))
		Object.defineProperties(root.CanvasRenderingContext2D.prototype, definify(canvasContextProps))
		Object.defineProperties(root.AudioContext.prototype, definify(audioProps))
	}
	redefine(window)
})()
